public function httpApproach(Request $request)
    {
        $user = $request->user();
        $prompt = $request->prompt;
        $character_id = $request->character_id;
        $user_id = $user->id;

        $character = Character::find($character_id);

        if (!$character) {
            return response()->json([
                'msgErr' => 'Character not found'
            ]);
        }

        // here we are checking the user, if the user is not exist then we are returning the error message, although we do not need this becouse we will implement middleware for this and every request will be authenticated
        if (!$user) {
            return response()->json([
                'msgErr' => 'User not found'
            ]);
        }

        if ($user->user_type == 'free') {
            $time_checkup = $this->count_users_request($user->id);

            if ($time_checkup['count'] > 9) {
                return response()->json([
                    'limitErr' => 'You have exceeded the limit of 10 requests in 6 hours. Please upgrade to paid version.',
                    'time' => $time_checkup['time_till_new_request']
                ]);
            }
        }

        try {

            // $chat_id = $request->chat_id;
            $chat_id = Chat::where('user_id', $user_id)->where('character_id', $character_id)->first()->id ?? null;

            // if no chat id, create new chat
            if (!$chat_id) {
                // create new chat
                $chat = Chat::create([
                    // currently no user
                    'user_id' => $user_id,
                    'character_id' => $character_id,
                    'prompt' => $prompt,
                    'completion' => ''
                ]);

                $chat_id = $chat->id;

                $recent_prompts = [];
            } else {
                // get recent 10 prompts
                $ten_recent_prompts = Prompt::search($prompt, $chat_id, $user_id);

                $recent_prompts = [];
                foreach ($ten_recent_prompts as $recent_prompt) {

                    $recent_prompts = array_merge($recent_prompts, [
                        [
                            'id' => $recent_prompt['id'],
                            'prompt' => $recent_prompt['prompt'],
                            'chat_id' => $recent_prompt['chat_id'],
                            'completion' => Prompt::find($recent_prompt['id'])["completion"]
                        ]
                    ]);
                }
            }

            $maxTokens = 250;
            $recent_formated_data = "";
            if ($recent_prompts) {
                foreach ($recent_prompts as $p) {
                    $recent_formated_data =   $recent_formated_data . "{prompt:" . $p["prompt"] . ",completion:" . $p["completion"] . "},";
                }
            }

            $open_ai_response = Http::withHeaders([
                'Content-Type' => 'application/json',
                'Authorization' => "Bearer " . env('OPENAI_KEY')
            ])
                ->post("https://api.openai.com/v1/engines/" . $this->models['davinci'] . "/completions", [
                    'prompt' => $character->character_description . "old prompts and completions." . $recent_formated_data . "Use old prompts and completions for memory about conversation,new Prompt:" . $prompt,
                    "temperature" => 0.7,
                    "max_tokens" => $maxTokens,
                    "top_p" => 1,
                    "frequency_penalty" => 0,
                    "presence_penalty" => 0,
                ])->json();

            $completion = str_replace(["\n\nCompletion:", "Completion:", "\n", "\r"], "", $open_ai_response['choices'][0]['text']);

            $prompt = Prompt::create([
                'prompt' => $prompt,
                'completion' =>  $completion,
                'user_id' => $user_id,
                'character_id' => $character_id,
                'chat_id' => $chat_id,
                'character_type' => $character->type
            ]);

            $response = Prompt::where('chat_id', $chat_id)->orderBy('id', 'desc')->first();
            $list = [];

            $list['prompt'] = $response['prompt'];
            $list['completion'] = $response['completion'];
            $list['id'] = $response['id'];
            $list['chat_id'] = $response['chat_id'];
            $list['character_id'] = $response['character_id'];
            $list['created_at'] = $response['created_at']->format('d M Y, h:i A');
            if ($user->user_type == 'free')
                $list['request_count'] = 10 - $this->count_users_request($user_id)['count'];

            return (!$open_ai_response) ?  "No response available!" : response()->json($list);
        } catch (\Throwable $th) {
            return  response()->json([
                'msgErr' => $th->getMessage()
            ]);
        }
    }